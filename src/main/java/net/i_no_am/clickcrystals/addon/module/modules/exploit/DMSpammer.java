package net.i_no_am.clickcrystals.addon.module.modules.exploit;

import io.github.itzispyder.clickcrystals.events.EventHandler;
import io.github.itzispyder.clickcrystals.events.events.world.ClientTickEndEvent;
import io.github.itzispyder.clickcrystals.modules.ModuleSetting;
import io.github.itzispyder.clickcrystals.modules.settings.SettingSection;
import io.github.itzispyder.clickcrystals.util.minecraft.ChatUtils;
import io.github.itzispyder.clickcrystals.util.minecraft.PlayerUtils;
import io.github.itzispyder.clickcrystals.util.misc.Timer;
import net.i_no_am.clickcrystals.addon.module.AddonListenerModule;
import net.minecraft.client.network.ClientPlayerEntity;

import java.util.*;
import java.util.stream.Collectors;

public class DMSpammer extends AddonListenerModule {

    public DMSpammer() {
        super("dm-spammer", "Spams private messages to selected players");
    }

    private final SettingSection scGeneral = getGeneralSection();

    public final ModuleSetting<String> targets = scGeneral.add(createStringSetting()
            .name("targets")
            .description("Comma-separated list of usernames to DM.")
            .def("player1,player2")
            .build()
    );

    public final ModuleSetting<String> ignores = scGeneral.add(createStringSetting()
            .name("ignored")
            .description("Comma-separated list of usernames to ignore.")
            .def("alex,steve")
            .build()
    );

    public final ModuleSetting<String> message = scGeneral.add(createStringSetting()
            .name("message")
            .description("Message to send.")
            .def("Hello there!")
            .build()
    );

    public final ModuleSetting<Integer> delayTicks = scGeneral.add(createIntSetting()
            .name("delay-ticks")
            .description("Average delay between each DM (in ticks, 20 ticks = 1 second).")
            .min(1)
            .max(200)
            .def(40)
            .build()
    );

    private final Map<String, Timer> cooldowns = new HashMap<>();
    private boolean warnedNoPlayers = false;

    @EventHandler
    private void onTick(ClientTickEndEvent e) {
        if (!isEnabled()) return;

        ClientPlayerEntity player = PlayerUtils.player();
        if (player == null || player.networkHandler == null) return;

        List<String> targetList = Arrays.stream(targets.getVal().split(","))
                .map(String::trim)
                .map(String::toLowerCase)
                .filter(s -> !s.isEmpty())
                .toList();

        List<String> ignoreList = Arrays.stream(ignores.getVal().split(","))
                .map(String::trim)
                .map(String::toLowerCase)
                .toList();

        if (targetList.isEmpty()) return;

        List<String> onlinePlayers = player.networkHandler.getPlayerList().stream()
                .map(entry -> entry.getProfile().getName().toLowerCase())
                .filter(name -> !ignoreList.contains(name) && targetList.contains(name))
                .collect(Collectors.toList());

        if (onlinePlayers.isEmpty()) {
            if (!warnedNoPlayers) {
                ChatUtils.sendPrefixMessage("Â§cNo target players are online or found!");
                warnedNoPlayers = true;
            }
            return;
        }

        warnedNoPlayers = false;
        Collections.shuffle(onlinePlayers);

        for (String target : onlinePlayers) {
            Timer cooldown = cooldowns.get(target);
            long cooldownMs = delayTicks.getVal() * 50L;

            if (cooldown != null && cooldown.end().timePassed() < cooldownMs) continue;

            ChatUtils.sendChatCommand("msg " + target + " " + message.getVal());

            cooldowns.put(target, Timer.start());

            break; // Send only to one player per tick
        }
    }
}